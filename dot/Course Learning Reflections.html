<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Course Learning Reflections</title>
  <style>
    body {
      font-family: Arial, sans-serif;
      line-height: 1.6;
      margin: 20px;
      background-color: #f9f9f9;
      color: #333;
    }
    h3, h4 {
      color: #2c3e50;
    }
    h3 {
      font-size: 24px;
      margin-bottom: 10px;
      border-bottom: 2px solid #3498db;
      padding-bottom: 5px;
    }
    h4 {
      font-size: 20px;
      margin-top: 20px;
    }
    h5 {
      font-size: 18px;
      margin-top: 10px;
      margin-bottom: 5px;
    }
    p {
      margin: 5px 0;
    }
    ul {
      margin-left: 20px;
    }
    ul li {
      margin: 5px 0;
      list-style-type: disc;
    }
    .container {
      max-width: 800px;
      margin: 0 auto;
      background: #ffffff;
      padding: 20px;
      border-radius: 8px;
      box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);
    }
  </style>
</head>
<body>
  <div class="container">
    <h3>Course Learning Reflections</h3>
    <h4>&bull; &nbsp;1.What are the kinds of problems we see in the nature? (iteration, recursion, backtracking)</h4>
    <h5>1. Iteration Problems</h5>
    <h5>Examples in Nature</h5>
    <p>Iteration means repeating steps in a loop until the job is done.</p>
    <ul>
      <li>Think of the sun rising and setting every day—it’s a repeating cycle.</li>
      <li>Counting the rings on a tree to know its age—each ring is added one at a time over the years.</li>
    </ul>
    
    <h5>Examples in Coding</h5>
    <ul>
      <li>Going through a list to find the largest number.</li>
      <li>Adding all the numbers in a group (like calculating your total grocery bill).</li>
    </ul>

    <h4>2. Recursion Problems</h4>
    <h5>Examples in Nature</h5>
    <p>Recursion is when a problem solves itself in smaller steps until it’s complete.</p>
    <ul>
      <li>Imagine a tree: A branch splits into smaller branches, which split into even smaller branches.</li>
      <li>Think of how you fold a piece of paper in half repeatedly—it’s the same process over and over.</li>
    </ul>
    
    <h5>Examples in Coding</h5>
    <ul>
      <li>Calculating factorials (e.g., 5! = 5 × 4 × 3 × 2 × 1).</li>
      <li>Finding your way through a family tree or exploring nested folders on your computer.</li>
    </ul>

    <h4>3. Backtracking Problems</h4>
    <h5>Examples in Nature</h5>
    <p>Backtracking is like trial and error: you try a path, and if it doesn’t work, you go back and try another one.</p>
    <ul>
      <li>Picture an ant trying to find food—it explores one path, and if it’s blocked, it turns around and tries a different way.</li>
      <li>Solving a maze: If one route doesn’t work, you go back and try a new direction.</li>
    </ul>
    
    <h5>Examples in Coding</h5>
    <ul>
      <li>Solving puzzles like Sudoku.</li>
      <li>Finding all possible combinations, like arranging letters to form words.</li>
      <li>Figuring out the shortest route on a map.</li>
    </ul>
    <h4>&bull; &nbsp;What is space and time efficiency? Why are they important? Explain the different class of problems and orders of growth</h4>
    <h5>Space and Time Efficiency</h5>
    <p>Time Efficiency is about how fast an algorithm runs. Imagine you’re baking a cake—time efficiency is how quickly you can finish baking.</p>
    <p>Space Efficiency is about how much memory or storage an algorithm uses while running. It’s like how many bowls or tools you need to bake that cake. The fewer, the better.</p>
    
    <h5>Why Are They Important?</h5>
    <ul>
      <li><strong>Save Time:</strong> Faster algorithms mean less waiting.</li>
      <li><strong>Save Memory:</strong> Efficient algorithms don’t use too much computer memory, so your device won’t slow down or crash.</li>
      <li><strong>Handle Bigger Problems:</strong> Efficient algorithms can process large amounts of data without issues.</li>
      <li><strong>Better User Experience:</strong> Nobody likes apps or websites that are slow and laggy.</li>
    </ul>

    <h5>Types of Problems</h5>
    <ul>
      <li><strong>Easy Problems (P):</strong> Problems that computers can solve quickly. For example, sorting a list of names or finding the shortest path on a map.</li>
      <li><strong>Tricky Problems (NP):</strong> Harder to solve but easy to check, like solving a jigsaw puzzle.</li>
      <li><strong>Super Tricky Problems (NP-Complete):</strong> The hardest puzzles. If we figure out a fast way to solve one of them, we can solve many other tricky problems just as fast.</li>
      <li><strong>Impossible Problems (NP-Hard):</strong> Problems so tough that no one knows how to solve them efficiently—or even check the answer easily in some cases.</li>
    </ul>
    <h5>Orders of Growth (How Algorithms Grow as Input Increases)</h5>
    <ul>
      <li><strong>O(1) – Constant Time:</strong> No matter the size, it always takes the same time. Example: Picking the first book from a pile.</li>
      <li><strong>O(log n) – Logarithmic Time:</strong> Grows slowly as input increases. Example: Finding a name in a phone book (binary search).</li>
      <li><strong>O(n) – Linear Time:</strong> Time grows directly with input size. Example: Reading all the books in a stack one by one.</li>
      <li><strong>O(n log n) – Linearithmic Time:</strong> Grows a bit faster, often seen in efficient sorting methods. Example: Sorting your books by size.</li>
      <li><strong>O(n²) – Quadratic Time:</strong> Time grows really fast, usually when there are nested loops. Example: Comparing every book with every other book.</li>
      <li><strong>O(2ⁿ) – Exponential Time:</strong> Time doubles with each new piece of data. Example: Trying every possible combination of books to find the best arrangement.</li>
      <li><strong>O(n!) – Factorial Time:</strong> Time explodes! Example: Arranging 10 books in every possible order (10! = 3,628,800 ways).</li>
    </ul>

    <h4>&bull; &nbsp;3.The hierarchical data and how different tree data structures solve and optimize over the problem scenarios (tree, bst, avl, 2-3, red-black, heap, trie)</h4>
    <h5>1. Basic Tree (Unbalanced Tree)</h5>
    <p><strong>Structure:</strong> A basic tree has nodes connected in a parent-child relationship but doesn't impose any ordering or balancing rules.</p>
    <p><strong>Problem:</strong> Search operations can be inefficient if the tree becomes unbalanced, potentially degrading to a linear structure (like a linked list).</p>
    <p><strong>Optimization:</strong> This is the most straightforward structure but doesn't optimize performance for large datasets.</p>

    <h5>2. Binary Search Tree (BST)</h5>
    <p><strong>Structure:</strong> A BST is a type of tree where each node has at most two children. For any given node, all nodes in the left subtree have smaller values, and all nodes in the right subtree have larger values.</p>
    <p><strong>Problem:</strong> If the tree becomes unbalanced (like a linked list), operations like search, insertion, and deletion can degrade to O(n) time complexity.</p>
    <p><strong>Optimization:</strong> Ideal for ordered data, allowing efficient searching, insertion, and deletion in O(log n) time for balanced trees.</p>

    <h5>3. AVL Tree (Adelson-Velsky and Landis Tree)</h5>
    <p><strong>Structure:</strong> An AVL tree is a self-balancing BST where the height difference between the left and right subtrees (called balance factor) of any node is at most 1.</p>
    <p><strong>Problem:</strong> Unbalanced BSTs lead to inefficient operations.</p>
    <p><strong>Optimization:</strong> AVL trees automatically balance themselves during insertions and deletions, ensuring that all operations remain O(log n). However, balancing operations (rotations) can slightly impact performance.</p>

    <h5>4. 2-3 Tree</h5>
    <p><strong>Structure:</strong> A 2-3 tree is a balanced tree where each node can have 2 or 3 children, and the tree remains perfectly balanced (all leaves are at the same level).</p>
    <p><strong>Problem:</strong> Maintaining balance and ordering in dynamic data can be difficult.</p>
    <p><strong>Optimization:</strong> The 2-3 tree maintains balance by splitting and merging nodes during insertions and deletions. It guarantees logarithmic time complexity for search, insertion, and deletion (O(log n)).</p>

    <h5>5. Red-Black Tree</h5>
    <p><strong>Structure:</strong> A red-black tree is a self-balancing binary search tree with an additional constraint on the colors of nodes (either red or black). This structure ensures that the tree remains approximately balanced.</p>
    <p><strong>Problem:</strong> Keeping a binary search tree balanced while allowing quick insertion and deletion.</p>
    <p><strong>Optimization:</strong> Red-black trees offer good performance with O(log n) operations for search, insert, and delete. The red-black tree is more relaxed than an AVL tree, offering faster insertions and deletions at the cost of slightly less strict balancing.</p>

    <h5>6. Heap (Binary Heap)</h5>
    <p><strong>Structure:</strong> A binary heap is a complete binary tree where the parent node is either greater than (max heap) or smaller than (min heap) its child nodes.</p>
    <p><strong>Problem:</strong> Finding the maximum or minimum element efficiently.</p>
    <p><strong>Optimization:</strong> Heaps are optimized for efficient priority queue operations. Operations like insertions and deletions take O(log n), while finding the max or min element takes O(1).</p>

    <h5>7. Trie (Prefix Tree)</h5>
    <p><strong>Structure:</strong> A trie is a tree-like data structure that stores strings. Each node represents a common prefix of some strings. It is particularly useful for handling large dictionaries or performing efficient prefix searches.</p>
    <p><strong>Problem:</strong> Storing and searching for strings, especially when working with large datasets like dictionaries.</p>
    <p><strong>Optimization:</strong> Tries allow fast lookups (O(m), where m is the length of the string) for both exact matching and prefix matching, making them ideal for applications like autocomplete, spell checkers, and dictionary searches.</p>

    <h4>&bull; &nbsp;4.The need of array query algorithms and their implications. Their applications and principles need to be discussed</h4>
    <h5>What Are Array Query Algorithms?</h5>
    <ul>
      <li>Find the sum of a few numbers in the list.</li>
      <li>Find the biggest or smallest number in a section of the list.</li>
      <li>Update a number in the list.</li>
    </ul>
    <h5>Why Do We Need These Algorithms?</h5>
    <ul>
      <li><strong>Speed: Without these algorithms, you'd have to check every number in the list, which can be slow, especially if you're asking the same question many times.</li>
      <li><strong>Efficiency: These algorithms make sure that even with huge lists, you can get the answer in a fraction of the time. This is important for things like real-time applications or large datasets.</li>
    </ul>
    <h5>Types of Array Query Algorithms:</h5>
    <h5>1.Prefix Sum (Cumulative Sum):</h5>
    <ul>
      <li><strong>What it does: It makes a new list where each element shows the total sum of all the numbers from the start to that point.</li>
      <li><strong>Why it's useful: Once you have this list, you can easily find the sum of any part of the original list. Instead of adding numbers one by one every time, you can find the sum in an instant.</li>
      <li>Example: Want the sum of numbers between position 3 and position 5? With prefix sums, you can get it right away.</li>
    </ul>
    <h5>2.Segment Tree:</h5>
    <ul>
      <li><strong>What it does: This is like a tree that helps you manage data in sections. Each section of the tree has a piece of your array, and you can quickly ask it for sums, maximums, or minimums in that section.</li>
      <li><strong>Why it's useful: If you're often asking about a part of the list (like the sum or max in a range), the segment tree helps answer those questions super fast.</li>
      <li>Example: In a game, if you want to know the highest score between levels 10 and 20, a segment tree can give you that quickly.</li>
    </ul>
    <h5>3.Binary Indexed Tree (BIT):</h5>
    <ul>
      <li><strong>What it does: It’s another way to store sums, but it’s designed for when you're updating the list and still need to do fast queries.</li>
      <li><strong>Why it's useful: If the list changes often and you still need quick answers, BIT helps balance the need for updates and queries efficiently.</li>
      <li>Example: Updating scores in a leaderboard and then asking for the total score quickly.</li>
    </ul>
    <h5>4.Sparse Table:</h5>
    <ul>
      <li><strong>What it does: This is for when the list doesn’t change much. It’s great for quickly answering questions like "What’s the smallest number in this part of the list?"</li>
      <li><strong>Why it's useful: It's super fast at answering these questions, but only if the list doesn’t change often.</li>
      <li>Example: Finding the lowest temperature in a city for the past month, if the data is mostly static.</li>
    </ul>
    <h5>Where Are These Algorithms Used?</h5>
    <ul>
      <li><strong>Financial Data: When you need to quickly calculate the sum of sales, stock prices, or transactions over a certain period, these algorithms can help you do it efficiently.</li>
      <li><strong>Gaming: If you’re keeping track of scores or health points and want to quickly know totals or maximums across levels, these algorithms can make those queries faster.</li>
      <li><strong>Search Engines: They help in answering complex queries about data stored in databases quickly.</li>
      <li><strong>Real-Time Systems: These algorithms are perfect when you need instant feedback, like in tracking real-time data (e.g., live sports scores).</li>
    </ul>
    <h5>How Do These Algorithms Work?</h5>
    <ul>
      <li><strong>Preprocessing: Some algorithms (like prefix sum) need you to set them up first by processing the whole list. Once that's done, you can get answers quickly whenever you need them.</li>
      <li><strong>Efficient Searching: Some algorithms (like segment trees or BITs) allow you to find answers to questions (like sum or max) in just a few steps, even if the list is huge.</li>
      <li><strong>Updating Data: For lists that change often, these algorithms let you update a number in the list quickly while still letting you ask questions efficiently.</li>
    </ul>
  </div>
</body>
</html>
